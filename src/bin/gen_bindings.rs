use std::{fs, path::PathBuf, process::Command};
use typescript_definitions::TypeScriptifyTrait;
use xbase::*;

fn main() {
    let root = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let ts_root = root.join("vscode");
    let lua_root = root.join("lua").join("xbase");
    let ts_types_path = ts_root.join("xbase").join("types.ts");
    let ts_constants_path = ts_root.join("xbase").join("constants.ts");
    let lua_constants_path = lua_root.join("constants.lua");

    gen_ts_types_file(ts_types_path);
    gen_ts_constant(ts_constants_path);
    gen_lua_constant(lua_constants_path);
    eslint_format(ts_root)
}

macro_rules! struct_to_lines {
    ($name:ident) => {
        $name::type_script_ify()
            .split("\n")
            .map(ToString::to_string)
    };
}

fn gen_ts_types_file(path: PathBuf) {
    let content = read_file_content(&path);
    let mut generated: Vec<String> = vec![];
    use {broadcast::*, server::*, types::*};

    generated.extend(
        server::Request::type_script_ify()
            .split("\n")
            .map(ToString::to_string),
    );

    generated.push("\n/* Server Requests */\n".into());

    generated.extend(struct_to_lines!(BuildRequest));
    generated.extend(struct_to_lines!(RunRequest));
    generated.extend(struct_to_lines!(RegisterRequest));
    generated.extend(struct_to_lines!(DropRequest));
    generated.extend(struct_to_lines!(GetProjectInfoRequest));

    generated.push("\n/* Server Response */\n".into());
    generated.extend(struct_to_lines!(ServerError));
    generated.extend(struct_to_lines!(Response));

    generated.push("\n/* General Transport types */\n".into());
    generated.extend(struct_to_lines!(ProjectInfo));
    generated.extend(struct_to_lines!(TargetInfo));
    generated.extend(struct_to_lines!(Runners));
    generated.extend(struct_to_lines!(Operation));
    generated.extend(struct_to_lines!(BuildSettings));
    generated.extend(struct_to_lines!(DeviceLookup));

    generated.push("\n/* Broadcast server Messages */\n".into());

    generated.extend(struct_to_lines!(Message));
    generated.extend(struct_to_lines!(ContentLevel));
    generated.extend(struct_to_lines!(TaskKind));
    generated.extend(struct_to_lines!(TaskStatus));

    for line in generated.iter_mut() {
        if line.starts_with(" |") {
            *line = line.replace(" |", "  |");
        }

        if line.ends_with("};") {
            *line = line.replace("};", "};\n");
        };

        if line.contains("Value") {
            *line = line.replace(": Value", ": unknown");
        } else if line.contains("Value") {
            *line = line.replace(": Error", ": ServerError");
        } else if line.contains("PBXTargetPlatform") {
            *line = line.replace(": PBXTargetPlatform", ": string");
        }

        *line = line.trim_end_matches(' ').to_string();
    }

    fs::write(&path, content + "\n" + &generated.join("\n"))
        .expect("failed to write typescript types");
}

fn gen_ts_constant(path: PathBuf) {
    let mut output = read_file_content(&path);

    macro_rules! export {
        ($key:ident) => {
            output += &format!("export const XBASE_{} = '{}'\n", stringify!($key), &*$key)
        };
    }

    export!(SOCK_ADDR);

    output += &format!(
        "export const XBASE_BIN_ROOT = '{BIN_ROOT}'.replace('$HOME', process.env.HOME!)\n"
    );

    fs::write(&path, output).expect("failed to write typescript types");
}

fn gen_lua_constant(path: PathBuf) {
    let mut output = read_file_content(&path);

    macro_rules! export {
        ($key:ident) => {
            output += &format!("M.{} = '{}'\n", stringify!($key), &*$key)
        };
    }

    export!(SOCK_ADDR);
    output += &format!("M.BIN_ROOT = string.gsub('{BIN_ROOT}', '$HOME', vim.env.HOME)\n",);
    output += "\n\nreturn M";

    fs::write(&path, output).expect("failed to write typescript types");
}

fn read_file_content(file: &PathBuf) -> String {
    let content = if file.exists() {
        fs::read_to_string(&file).unwrap()
    } else {
        Default::default()
    };
    let lines = content.split('\n').collect::<Vec<&str>>();
    let marker = lines
        .iter()
        .position(|line| line.contains("AUTOGENERATED"))
        .unwrap_or_default();

    String::from(&lines[0..marker + 1].join("\n")) + "\n"
}

fn eslint_format(ts_root: PathBuf) {
    let format_status = Command::new(ts_root.join("node_modules").join(".bin").join("prettier"))
        .arg(ts_root.join("xbase").join("types.ts"))
        .arg("--write")
        .output()
        .expect("failed to run pnpm lint on ts_out")
        .status;

    assert!(format_status.success(), "pnpm lint failed");
}
