use std::{fs, path::PathBuf, process::Command};
use typescript_definitions::TypeScriptifyTrait;
use which::which;
use xbase::*;

fn main() {
    let root = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let ts_root = root.join("vscode");
    let lua_root = root.join("lua").join("xbase");
    let ts_types_path = ts_root.join("src").join("types.ts");
    let ts_constants_path = ts_root.join("src").join("constants.ts");
    let lua_constants_path = lua_root.join("constants.lua");

    gen_ts_types_file(ts_types_path);
    gen_ts_constant(ts_constants_path);
    gen_lua_constant(lua_constants_path);
    eslint_format(ts_root)
}

fn gen_ts_types_file(path: PathBuf) {
    let mut output = read_file_content(&path);

    output += &server::Request::type_script_ify();

    output += "// Server Requests\n\n";
    output += &server::BuildRequest::type_script_ify();
    output += &server::RunRequest::type_script_ify();
    output += &server::RegisterRequest::type_script_ify();
    output += &server::DropRequest::type_script_ify();
    output += &server::GetProjectInfoRequest::type_script_ify();

    output += "// Server Response\n\n";
    output += &error::ServerError::type_script_ify();
    output += &server::Response::type_script_ify();

    output += "// General Transport types\n\n";
    output += &server::ProjectInfo::type_script_ify();
    output += &types::TargetInfo::type_script_ify();
    output += &server::Runners::type_script_ify();
    output += &types::Operation::type_script_ify();
    output += &types::BuildSettings::type_script_ify();
    output += &types::DeviceLookup::type_script_ify();

    output += "// Broadcast server Messages\n\n";

    output += &broadcast::Message::type_script_ify();
    output += &broadcast::MessageLevel::type_script_ify();
    output += &broadcast::Task::type_script_ify();
    output += &broadcast::StatuslineState::type_script_ify();

    output = output.replace(": Value", ": unknown");
    output = output.replace(": Error", ": ServerError");
    output = output.replace(": PBXTargetPlatform", ": string");
    output = output.replace("};", "}\n\n");

    while output.contains("  ") {
        output = output.replace("  ", " ");
    }
    for _ in 0..5 {
        output = output.replace("\r\n\r\n", "    \n");
    }

    fs::write(&path, output).expect("failed to write typescript types");
}

fn gen_ts_constant(path: PathBuf) {
    let mut output = read_file_content(&path);

    macro_rules! export {
        ($key:ident) => {
            output += &format!("export const XBASE_{} = '{}'\n", stringify!($key), &*$key)
        };
    }

    export!(SOCK_ADDR);

    output += &format!(
        "export const XBASE_BIN_ROOT = '{BIN_ROOT}'.replace('$HOME', process.env.HOME!)\n"
    );

    fs::write(&path, output).expect("failed to write typescript types");
}

fn gen_lua_constant(path: PathBuf) {
    let mut output = read_file_content(&path);

    macro_rules! export {
        ($key:ident) => {
            output += &format!("M.{} = '{}'\n", stringify!($key), &*$key)
        };
    }

    export!(SOCK_ADDR);
    output += &format!("M.BIN_ROOT = string.gsub('{BIN_ROOT}', '$HOME', vim.env.HOME)\n",);
    output += "\n\nreturn M";

    fs::write(&path, output).expect("failed to write typescript types");
}

fn read_file_content(file: &PathBuf) -> String {
    let content = if file.exists() {
        fs::read_to_string(&file).unwrap()
    } else {
        Default::default()
    };
    let lines = content.split('\n').collect::<Vec<&str>>();
    let marker = lines
        .iter()
        .position(|line| line.contains("AUTOGENERATED"))
        .unwrap_or_default();

    String::from(&lines[0..marker + 1].join("\n")) + "\n"
}

fn eslint_format(ts_root: PathBuf) {
    let pnpm = which("pnpm").unwrap();
    let format_status = Command::new(pnpm)
        .current_dir(ts_root)
        .args(&["lint", "--fix"])
        .output()
        .expect("failed to run pnpm lint on ts_out")
        .status;

    assert!(format_status.success(), "pnpm lint failed");
}
